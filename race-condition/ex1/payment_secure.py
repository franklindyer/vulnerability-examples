import sqlite3
import random
import string
import time
from flask import Flask, render_template, request, make_response, redirect

def float_convert(x):
    cents = (x % 20)
    dollars = int((x-cents)/20)
    cents = str(cents*5)
    if cents == "0":
        cents = "00"
    if cents == "5":
        cents = "05"
    dollars = str(dollars)
    return dollars + "." + cents

MAX_USERNAME_LEN = 20
MAX_PASSWORD_LEN = 30
MAX_MESSAGE_LEN = 300
SESSIONID_LEN = 30
MAX_PAYMENT = 1000

DATABASE_NAME = 'accounts.db'

class PaymentException(Exception):
    pass
class EBadLoginString(PaymentException):
    pass
class EIncorrectLogin(PaymentException):
    pass
class ENotLoggedIn(PaymentException):
    pass
class EBadRecipient(PaymentException):
    pass
class EBadPaymentString(PaymentException):
    pass
class EInsufficientFunds(PaymentException):
    pass
class EBadMessage(PaymentException):
    pass
class EMiscPaymentError(PaymentException):
    pass

class PaymentSyntaxChecker:
    def __init__(self, semanticChecker):
        self.target = semanticChecker

    def get_statistic(self, stat):
        return self.target.get_statistic(stat)

    def sanitize_username(self, user_string):
        if not user_string.isalnum():
            raise EBadLoginString()
        if len(user_string) > MAX_USERNAME_LEN:
            raise EBadLoginString()
        return user_string

    def sanitize_password(self, pass_string):
        if len(pass_string) > MAX_PASSWORD_LEN:
            raise EBadLoginString()
        return pass_string

    def sanitize_recipient_id(self, rid_string):
        try:
            rid = int(rid_string)
            return rid
        except:
            raise EBadRecipient()

    def sanitize_transfer_amount(self, amt_string):
        try:
            amt = float(amt_string)
            return amt
        except:
            raise EBadPaymentString()

    def sanitize_transfer_message(self, message_string):
        if len(message_string) > MAX_MESSAGE_LEN:
            raise EBadMessage()
        return message_string

    def sanitize_session_id(self, sessid_string):
        if sessid_string == None or len(sessid_string) != SESSIONID_LEN:
            raise ENotLoggedIn()
        return sessid_string

    def login_action(self, username_string, password_string):
        username = self.sanitize_username(username_string)
        password = self.sanitize_password(password_string)
        return self.target.login_action(username, password)

    def session_action(self, sessid_string):
        sessid = self.sanitize_session_id(sessid_string)
        return self.target.session_action(sessid)

    def payment_action(self, recip_string, amt_string, msg_string, sessid_string):
        rid = self.sanitize_recipient_id(recip_string)
        amt = self.sanitize_transfer_amount(amt_string)
        msg = self.sanitize_transfer_message(msg_string)
        sess_id = self.sanitize_session_id(sessid_string)
        return self.target.payment_action(rid, amt, msg, sess_id)

    def logout_action(self, sessid_string):
        sess_id = self.sanitize_session_id(sessid_string)
        return self.target.logout_action(sess_id)

class PaymentSemanticsChecker:    
    def __init__(self, model):
        self.target = model

    def get_statistic(self, stat):
        conn = self.get_db_connection()
        ans = None
        if stat == "total_users":
            ans = conn.execute("SELECT COUNT(*) FROM users;").fetchone()[0]
        elif stat == "total_money":
            ans = conn.execute("SELECT SUM(balance) FROM users;").fetchone()[0]
        conn.close()
        return ans

    def get_db_connection(self):
        conn = sqlite3.connect('file:./' + DATABASE_NAME + '?mode=ro', uri=True)
        conn.row_factory = sqlite3.Row
        return conn

    def check_username_password(self, username, password):
        conn = self.get_db_connection()
        res = conn.execute("SELECT id FROM users WHERE username=? AND password=?;", (username, password,))
        uid = res.fetchone()[0]
        if (uid == None):
            raise EIncorrectLogin
        conn.close()
        return uid

    def check_session_id(self, session_id):
        conn = self.get_db_connection()
        res = conn.execute("SELECT id FROM users WHERE session_key=?;", (session_id,))
        row = res.fetchone()
        if (row == None):
            raise ENotLoggedIn
        uid = row[0]
        conn.close()
        return uid

    def check_recipient_id(self, sid, rid):
        conn = self.get_db_connection()
        res = conn.execute("SELECT id FROM users WHERE id=?;", (rid,))
        if (res.fetchone() == None):
            raise EBadRecipient
        if sid == rid:
            raise EBadRecipient
        conn.close()
        return rid

    def check_transfer_amount(self, sid, amt):
        conn = self.get_db_connection()
        res = conn.execute("SELECT balance FROM users WHERE id=?;", (sid,))
        sbalance = res.fetchone()[0]
        amt_converted = int(amt*20)     # The smallest transactional unit is 5-cent increments
        if amt_converted <= 0:
            raise EBadPaymentString
        if amt_converted > MAX_PAYMENT*20:
            raise EBadPaymentString 
        if amt_converted > sbalance:
            raise EInsufficientFunds
        conn.close()
        return amt_converted

    def check_transfer_message(self, msg):
        return msg

    def login_action(self, username, password):
        uid = self.check_username_password(username, password)
        return self.target.login_action(uid)

    def session_action(self, session_id):
        uid = self.check_session_id(session_id)
        return self.target.session_action(uid)

    def payment_action(self, recip, amt, msg, sess_id):
        uid = self.check_session_id(sess_id)
        rid = self.check_recipient_id(uid, recip)
        amt_converted = self.check_transfer_amount(uid, amt)
        message = self.check_transfer_message(msg)
        time.sleep(0.1) # To make the race condition extra easy to exploit!
        return self.target.payment_action(uid, rid, amt_converted, message)

    def logout_action(self, sess_id):
        uid = self.check_session_id(sess_id)
        return self.target.logout_action(uid)

class PaymentModel:
    def __init__(self, paymentServer):
        self.target = paymentServer

    def get_db_connection(self):
        conn = sqlite3.connect(DATABASE_NAME)
        conn.row_factory = sqlite3.Row
        return conn

    def generate_session_key(self):
        return ''.join(random.choice(string.ascii_lowercase) for i in range(30))

    def login_action(self, uid):
        conn = self.get_db_connection()
        sess_id = self.generate_session_key()
        conn.execute("UPDATE users SET session_key=? WHERE id=?;", (sess_id, uid,))
        conn.commit()
        conn.close()
        return self.target.login_action(sess_id)

    def session_action(self, uid):
        return self.target.session_action(uid)

    def payment_action(self, uid, rid, amt_converted, message):
        conn = self.get_db_connection()
        conn.execute("UPDATE users SET balance=balance-? WHERE id=?;", (amt_converted, uid,))
        conn.execute("UPDATE users SET balance=balance+? WHERE id=?;", (amt_converted, rid,))
        conn.execute("INSERT INTO transactions (sender, receiver, amount, reason) VALUES (?,?,?,?);", (uid,rid,amt_converted,message))
        conn.commit()
        conn.close()
        return self.target.payment_action()

    def logout_action(self, uid):
        conn = self.get_db_connection()
        conn.execute("UPDATE users SET session_key='' WHERE id=?;", (uid,))
        conn.commit()
        conn.close()
        return self.target.logout_action(uid)

class PaymentPageServer():

    def get_db_connection(self):
        conn = sqlite3.connect('file:./' + DATABASE_NAME + '?mode=ro', uri=True)
        conn.row_factory = sqlite3.Row
        return conn

    def login_action(self, sess_id):
        resp = make_response(redirect('/home', code=302))
        resp.set_cookie('session_id', sess_id)
        return resp

    def session_action(self, uid):
        conn = self.get_db_connection()
        user = conn.execute("SELECT * FROM users WHERE id=?;", (uid,)).fetchone()
        user_list = conn.execute("SELECT id, username FROM users;").fetchall()
        pay_history = conn.execute("SELECT * FROM transactions WHERE sender=? OR receiver=? ORDER BY timestamp;", (uid, uid,)).fetchall()
        return render_template("home.html", user=user, user_list=user_list, pay_history=pay_history, float_convert=float_convert)

    def payment_action(self):
        return redirect("/home", code=302)

    def logout_action(self, uid):
        return redirect("/", code=302)

    def error_page(self, ex):
        try:
            raise ex
        except EBadLoginString:
            return f"Invalid login strings. Usernames should be alphanumeric and {MAX_USERNAME_LEN} characters or fewer, and passwords should be alphanumeric and {MAX_PASSWORD_LEN} characters or fewer."
        except EIncorrectLogin:
            return "Incorrect credentials."
        except ENotLoggedIn:
            return "You are not logged in. <a href='/'>Go log in.</a>"
        except EBadRecipient:
            return "Invalid payment. That recipient does not exist. Please try again."
        except EBadPaymentString:
            return f"Invalid payment amount. Payment must be a positive amount less than {MAX_PAYMENT} and will be rounded to the nearest 5 cents."
        except EInsufficientFunds:
            return "You have insufficient funds for that transaction."
        except EBadMessage:
            return f"Please keep your message to under {MAX_MESSAGE_LEN} characters."
        except EMiscPaymentError:
            return "Something went wrong with your payment. Please try again."

class PaymentApp:
    def __init__(self):
        self.pageServer = PaymentPageServer()
        self.model = PaymentModel(self.pageServer)
        self.semanticChecker = PaymentSemanticsChecker(self.model)
        self.syntaxChecker = PaymentSyntaxChecker(self.semanticChecker)
        self.entryPoint = self.syntaxChecker

    def get_statistic(self, stat):
        return self.entryPoint.get_statistic(stat)

    def login_action(self, user_string, pass_string):
        try:
            return self.entryPoint.login_action(user_string, pass_string)
        except Exception as ex:
            return self.pageServer.error_page(ex)

    def session_action(self, sessid_string):
        try:
            return self.entryPoint.session_action(sessid_string)
        except Exception as ex:
            return self.pageServer.error_page(ex)

    def payment_action(self, recip_string, amt_string, msg_string, sessid_string):
        try:
            return self.entryPoint.payment_action(recip_string, amt_string, msg_string, sessid_string)
        except Exception as ex:
            return self.pageServer.error_page(ex)

    def logout_action(self, sessid_string):
        try:
            return self.entryPoint.logout_action(sessid_string)
        except Exception as ex:
            return self.pageServer.error_page(ex)
