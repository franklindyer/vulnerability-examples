import sqlite3
from flask import Flask, render_template, request, make_response, redirect

MAX_USERNAME_LEN = 20
MAX_PASSWORD_LEN = 30
MAX_MESSAGE_LEN = 300
SESSIONID_LEN = 30
MAX_PAYMENT = 1000

DATABASE_NAME = 'accounts.db'

class PaymentException(Exception):
    pass
class EBadLoginString(PaymentException):
    pass
class EIncorrectLogin(PaymentException):
    pass
class ENotLoggedIn(PaymentException):
    pass
class EBadRecipient(PaymentException):
    pass
class EBadPaymentString(PaymentException):
    pass
class EInsufficientFunds(PaymentException):
    pass
class EBadMessage(PaymentException):
    pass
class EMiscPaymentError(PaymentException):
    pass

class PaymentSyntaxChecker:
    def __init__(self, semanticChecker):
        this.target = semanticChecker

    def sanitize_username(self, user_string):
        if not isalnum(user_string):
            raise EBadLoginString()
        if len(user_string) > MAX_USERNAME_LEN:
            raise EBadLoginString()
        return user_string

    def sanitize_password(self, pass_string):
        if len(pass_string) > MAX_PASSWORD_LEN:
            raise EBadLoginString()
        return pass_string

    def sanitize_recipient_id(self, rid_string):
        try:
            rid = int(rid_string)
            return rid
        except:
            raise EBadRecipient()

    def sanitize_transfer_amount(self, amt_string):
        try:
            amt = float(amt_string)
            return amt
        except:
            raise EBadPaymentString()

    def sanitize_transfer_message(self, message_string):
        if len(message_string) > MAX_MESSAGE_LEN:
            raise EBadMessage()
        return message_string

    def sanitize_session_id(self, sessid_string):
        if len(sessid_string) != SESSIONID_LEN:
            raise ENotLoggedIn()
        return sessid_string

    def login_action(self, username_string, password_string):
        username = self.sanitize_username(username_string)
        password = self.sanitize_password(password_string)
        return self.target.login_action(username, password)

    def session_action(self, sessid_string):
        sessid = self.sanitize_session_id(sessid_string)
        return self.target.session_action(sessid)

    def payment_action(self, recip_string, amt_string, msg_string, sessid_string):
        rid = self.sanitize_recipient_id(recip_string)
        amt = self.sanitize_transfer_amount(amt_string)
        msg = self.sanitize_transfer_message(msg_string)
        sess_id = self.sanitize_session_id(sessid_string)
        return self.target.payment_action(self, rid, amt, msg, sess_id)

    def logout_action(self, sessid_string):
        sess_id = self.sanitize_session_id(sessid_string)
        return self.target.logout_action(sess_id)

class PaymentSemanticsChecker:    
    def __init__(self, model):
        this.target = model

    def get_db_connection(self):
        conn = sqlite3.connect(DATABASE_NAME + '?mode=ro')
        conn.row_factory = sqlite3.Row
        return conn

    def check_username_password(self, username, password):
        conn = self.get_db_connection()
        res = conn.execute("SELECT uid FROM users WHERE username=? AND password=?;", (username, password,))
        uid = res.fetchone()
        if (uid == None):
            raise EIncorrectLogin
        conn.close()
        return uid

    def check_session_id(self, session_id):
        conn = self.get_db_connection()
        res = conn.execute("SELECT uid FROM users WHERE session_key=?;", (session_id,))
        uid = res.fetchone()
        if (uid == None):
            raise ENotLoggedIn
        conn.close()
        return uid

    def check_recipient_id(self, sid, rid):
        conn = self.get_db_connection()
        res = conn.execute("SELECT uid FROM users WHERE uid=?;", (rid,))
        if (res.fetchone() == None):
            raise EBadRecipient
        if sid == rid:
            raise EBadRecipient
        conn.close()
        return rid

    def check_transfer_amount(self, sid, amt):
        conn = self.get_db_connection()
        res = conn.execute("SELECT balance FROM users WHERE uid=?;", (sid,))
        sbalance = res.fetchone()[0]
        amt_converted = int(amt*20)     # The smallest transactional unit is 5-cent increments
        if amt_converted <= 0:
            raise EBadPaymentString
        if amt_converted > MAX_PAYMENT:
            raise EBadPaymentString 
        if amt_converted > sbalance:
            raise EInsufficientFunds
        conn.close()
        return (sbalance, amt_converted)

    def check_transfer_message(self, msg):
        return msg

    def login_action(self, username, password):
        uid = self.check_username_password(username, password)
        self.target.login_action(uid)

    def session_action(self, session_id):
        uid = self.check_session_id(session_id)
        self.target.session_action(uid)

    def payment_action(self, recip, amt, msg, sess_id):
        uid = self.check_session_id(session_id)
        rid = self.check_recipient_id(recip)
        prev_bal, amt_converted = self.check_transfer_amount(uid, amt)
        message = self.check_transfer_message(msg)
        self.target.payment_action(uid, rid, amt_converted, message, prev_bal)

    def logout_action(self, sess_id):
        uid = self.check_session_id(sess_id)
        return self.target.logout_action(uid)

class PaymentModel:
    def __init__(self, paymentServer):
        self.target = paymentServer

    def get_db_connection(self):
        conn = sqlite3.connect(DATABASE_NAME)
        conn.row_factory = sqlite3.Row
        return conn

    def generate_session_key(self):
        return ''.join(random.choice(string.ascii_lowercase) for i in range(30))

    def login_action(self, uid):
        conn = self.get_db_connection()
        sess_id = self.generate_session_key()
        conn.execute("UPDATE users SET session_key=? WHERE id=?;", (sess_id, uid,))
        conn.commit()
        conn.close()
        return self.target.login_action(uid)

    def session_action(self, uid):
        return self.target.session_action(uid)

    def payment_action(self, uid, rid, amt_converted, message, prev_bal):
        conn = self.get_db_connection()
        cur_bal = conn.execute("SELECT balance FROM users WHERE id=?;", (uid,)).fetchone()[0]
        if cur_bal != prev_bal:
            raise EMiscPaymentError
        new_sbalance = cur_bal - amt_converted
        new_rbalance = conn.execute("SELECT balance FROM users WHERE id=?;", (rid,)).fetchone()[0] + amt_converted
        conn.execute("UPDATE users SET balance=? WHERE id=?;", (new_sbalance, uid,))
        conn.execute("UPDATE users SET balance=? WHERE id=?;", (new_rbalance, rid,))
        conn.commit()
        conn.close()
        return self.target.payment_action()

    def logout_action(self, uid):
        conn = self.get_db_connection()
        conn.execute("UPDATE users SET session_key='' WHERE id=?;", (uid,))
        conn.commit()
        conn.close()
        return self.target.logout_action()

class PaymentPageServer():
    def __init__(self):

    def get_db_connection(self):
        conn = sqlite3.connect(DATABASE_NAME + '?mode=ro')
        conn.row_factory = sqlite3.Row
        return conn

    def login_action(self, uid):
        return redirect("/home", code=302)

    def session_action(self, uid):
        conn = self.get_db_connection()
        user = conn.execute("SELECT * FROM users WHERE id=?;", (uid,)).fetchone()
        user_list = conn.execute("SELECT id, username FROM users;").fetchall()
        pay_history = conn.execute("SELECT * FROM transactions WHERE sender=? OR receiver=? ORDER BY timestamp;", (uid, uid,)).fetchall()
        return render_template("home.html", user=user, user_list=user_list, pay_history=pay_history)

    def payment_action(self):
        return redirect("/home", code=302)

    def logout_action(self, uid):
        return redirect("/", code=302)

class PaymentApp:
    def __init__(self):
        self.pageServer = new PaymentPageServer()
        self.model = new PaymentModel(self.pageServer)
        self.semanticChecker = new PaymentSemanticsChecker(self.model)
        self.syntaxChecker = new PaymentSyntaxChecker(self.semanticChecker)
        self.entryPoint = self.syntaxChecker

    def login_action(self, user_string, pass_string):
        return self.entryPoint.login_action(user_string, pass_string)

    def session_action(self, sessid_string):
        return self.entryPoint.session_action(sessid_string)

    def payment_action(self, recip_string, amt_string, msg_string, sessid_string):
        return self.entryPoint.payment_action(recip_string, amt_string, msg_string, sessid_string)

    def logout_action(self, sessid_string):
        return self.entryPoint.logout_action(sessid_string)
